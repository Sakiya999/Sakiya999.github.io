{"meta":{"title":"Sakiya的个人博客","subtitle":"","description":"","author":"John Doe","url":"http://sakiya.top","root":"/"},"pages":[{"title":"404 Not Found：你来到了一座还未开拓的荒岛","date":"2022-06-14T06:59:16.400Z","updated":"2022-06-14T06:59:16.400Z","comments":false,"path":"/404.html","permalink":"http://sakiya.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-06-14T07:02:13.903Z","updated":"2022-06-14T07:02:13.903Z","comments":false,"path":"about/index.html","permalink":"http://sakiya.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-06-14T07:01:59.367Z","updated":"2022-06-14T07:01:59.367Z","comments":false,"path":"categories/index.html","permalink":"http://sakiya.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-14T06:59:47.715Z","updated":"2022-06-14T06:59:47.714Z","comments":false,"path":"tags/index.html","permalink":"http://sakiya.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js使用代理访问websocket","slug":"nodejs-ws-proxy","date":"2022-07-06T08:15:35.000Z","updated":"2022-07-06T08:23:21.905Z","comments":true,"path":"2022/07/06/nodejs-ws-proxy/","link":"","permalink":"http://sakiya.top/2022/07/06/nodejs-ws-proxy/","excerpt":"","text":"为了在websocket中使用代理访问，需要使用 https-proxy-agent 包，安装方式如下： 1npm install https-proxy-agent 接下来是示例代码： 12345678910111213141516171819202122var url = require(&#x27;url&#x27;);var WebSocket = require(&#x27;ws&#x27;);var HttpsProxyAgent = require(&#x27;https-proxy-agent&#x27;);// 填入你的代理var proxy = &#x27;http://localhost:7890&#x27;;// 需要访问的websocket地址var endpoint = &#x27;ws://echo.websocket.org&#x27;;var options = url.parse(proxy);var agent = new HttpsProxyAgent(options);// 使用proxy agent 初始化websocketvar ws_client = new WebSocket(endpoint, &#123; agent: agent &#125;);ws_client.on(&#x27;open&#x27;, function () &#123; console.log(&#x27;&quot;open&quot; event!&#x27;);&#125;);ws_client.on(&#x27;message&#x27;, function (data, flags) &#123; console.log(&#x27;&quot;message&quot; event! %j %j&#x27;, data, flags);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://sakiya.top/categories/nodejs/"}],"tags":[]},{"title":"Solana中Approve和Revoke","slug":"solana-approve-revoke","date":"2022-07-04T08:15:01.000Z","updated":"2022-07-04T08:49:53.115Z","comments":true,"path":"2022/07/04/solana-approve-revoke/","link":"","permalink":"http://sakiya.top/2022/07/04/solana-approve-revoke/","excerpt":"","text":"Solana的链自带Token程序，其中也有类似以太坊中ERC20代币中Approve的功能。 当使用Approve将Token账户授权给其他账户以后，被授权账户就可以转移被授权的金额。 另外，授权的账户的owner也可以使用Revoke操作将这个授权取消掉。 下面展示代码。 首先展示一下.env的配置参数： 1234TARGET_ACCOUNT = &quot;&lt;授权Token账号地址&gt;&quot;DELEGATE_ACCOUNT = &quot;&lt;被授权账号地址&gt;&quot;OWNER_PRIVATE_KEY = &quot;&lt;授权Token账号的主账号&gt;&quot;CONNECTION_RPC = &quot;&lt;连接Solana的RPC地址&gt;&quot; 接下来是approve和revoke的代码，这里使用了 @solana/spl-token 库， 版本是0.1.8。这个库最新的0.2.0接口全变掉了，暂时懒得改了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576require(&#x27;dotenv&#x27;).config();const web3 = require(&quot;@solana/web3.js&quot;);const splToken = require(&#x27;@solana/spl-token&#x27;);const bs58 = require(&#x27;bs58&#x27;);const &#123; TARGET_ACCOUNT, DELEGATE_ACCOUNT, OWNER_PRIVATE_KEY, CONNECTION_RPC&#125; = process.env;var connection = new web3.Connection( CONNECTION_RPC);function get_approve_instruction(owner) &#123; // 这里要保证target_account存在，自动创建的代码没写，如果不存在可以做个转账之类的操作。 // 授权的token地址 let target_account = new web3.PublicKey(TARGET_ACCOUNT); // 被授权的地址 let delegate_account = new web3.PublicKey(DELEGATE_ACCOUNT); // 授权金额 let amount = &quot;1000&quot;; let instruction = splToken.Token.createApproveInstruction( splToken.TOKEN_PROGRAM_ID, target_account, delegate_account, owner.publicKey, [], amount ); console.log(&quot;apprvoe instruction:&quot;,instruction); return instruction;&#125;function get_revoke_instruction(owner) &#123; let target_account = new web3.PublicKey(TARGET_ACCOUNT); let instruction = splToken.Token.createRevokeInstruction( splToken.TOKEN_PROGRAM_ID, target_account, owner.publicKey, [], ); console.log(&quot;revoke instruction:&quot;, instruction); return instruction;&#125;(async ()=&gt; &#123; const decoded_key = bs58.decode(OWNER_PRIVATE_KEY); let owner = new web3.Account(decoded_key); console.log(&quot;owner address:&quot;, owner.publicKey.toString()); let transaction = new web3.Transaction(); let approve_instruction = get_approve_instruction(owner); let revoke_instruction = get_revoke_instruction(owner); transaction.add(approve_instruction); transaction.add(revoke_instruction); console.log(transaction) const signature = await web3.sendAndConfirmTransaction( connection, transaction, [owner], &#123;commitment: &#x27;confirmed&#x27;&#125;, ); console.log(&#x27;SIGNATURE:&#x27;, signature);&#125;)(); 这里先approve，然后revoke掉，可以在solanascan里看具体细节。 当你approve以后，就可以用被授权的账号把授权账号的余额转出去了，代码大概是这样： 12345678910111213const decoded_key = bs58.decode(&quot;&lt;singer 私钥，可以用之前delegate_account的主账号&gt;&quot;);let account = new web3.Account(decoded_key);let token_address = &quot;EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&quot;;let token = new splToken.Token( connection, new web3.PublicKey(token_address), splToken.TOKEN_PROGRAM_ID, account);let source_address = new web3.PublicKey(&quot;&lt;授权地址，即之前的target_account&gt;&quot;);let destination_address = new web3.PublicKey(&quot;&lt;转账目标地址，可以用之前的delegate_account&gt;&quot;);await token.transfer(source_address, destination_address, account, [], &quot;100&quot;); 感觉solana的机制有点不安全，以太坊ERC20的Approve至少有个保护，不能用合约去Approve的，每次发生授权操作人还能检查一下（虽然感觉很多人也不看）。但solana的这个Approve，我就可以偷偷藏在合约里，approve了你不仔细看交易记录，可能都不知道，等某天直接把你的币转走也不是不可能。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"http://sakiya.top/tags/Solana/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"如何使用Ether.js进行交易","slug":"etherjs","date":"2022-06-20T13:11:09.000Z","updated":"2022-06-22T03:17:14.385Z","comments":true,"path":"2022/06/20/etherjs/","link":"","permalink":"http://sakiya.top/2022/06/20/etherjs/","excerpt":"","text":"ether.js用于与以太坊区块链及其生态系统进行交互。这里只介绍用于链上交易的一部分功能，更详细的内容还是需要查看官方文档：https://docs.ethers.io/。 安装 1npm install --save ethers Provider 当你想要访问区块链上的数据时，你需要一个rpc地址，Provider会为你生成一个访问数据的对象。ether.js提供了多个节点提供商生成Provider的接口，比如infura，Alchemy，Ankr，Pocket Gateway等等。这里就不去分辨它的优劣了，我这里还是使用更为通用的方式生成Provider。 123456789101112131415const &#123; ethers &#125; = require(&quot;ethers&quot;);// http rpcvar url = &#x27;https://eth.public-rpc.com&#x27;;var customHttpProvider = new ethers.providers.JsonRpcProvider(url);// wss rpcvar wss_url = &quot;wss://eth-mainnet.alchemyapi.io/v2/&lt;API_KEY&gt;&quot;;var customWssProvider = new ethers.providers.WebSocketProvider(wss_url);(async()=&gt;&#123; let block_number = await customHttpProvider.getBlockNumber(); console.log(&quot;http block_number:&quot;, block_number); block_number = await customWssProvider.getBlockNumber(); console.log(&quot;wss block_number:&quot;, block_number);&#125;)(); 接下来一些查询的操作就可以通过Provider去做了，具体可以参考https://docs.ethers.io/v5/api/providers/provider/#Provider–account-methods 。 添加账号 接下来如果需要进行交易，就避免不了和账号的交互。ether.js提供了两种形式： Wallet : 需要提供私钥，可以进行全部的操作。 JsonRpcSigner： 这种代码是没有私钥的，需要使用getSigner获取账号，适用于连接了你的私有节点，使用Ganache测试或者连小狐狸钱包等情况，需要私钥签名的操作会由对应的其他模块进行处理。 先说Wallet，使用私钥初始化就可以调用相关方法了: 1234567891011121314151617181920212223242526272829require(&#x27;dotenv&#x27;).config();const &#123; ethers &#125; = require(&quot;ethers&quot;);const &#123;ACCOUNT_PRIVATE_KEY, RPC_URL&#125; = process.env;var customHttpProvider = new ethers.providers.JsonRpcProvider(RPC_URL);const signer = new ethers.Wallet(ACCOUNT_PRIVATE_KEY, customHttpProvider);(async()=&gt;&#123; // 获取公钥地址 console.log(&quot;account address: &quot;,signer.address); // 私钥地址 console.log(&quot;account privateKey: &quot;, signer.privateKey); // 获取余额 console.log(&quot;account balance: &quot;, await signer.getBalance()); // 使用私钥签名信息 console.log(&quot;account sign message: &#x27;Hello World!&#x27;&quot;, await signer.signMessage(&quot;Hello World!&quot;)); // 打印nonce console.log(&quot;account nonce:&quot;, await signer.getTransactionCount()); // 发送最简单的交易，给自己发eth let tx = &#123; to: signer.address, value: ethers.utils.parseEther(&quot;0.001&quot;) &#125;; let send_result = await signer.sendTransaction(tx); console.log(&quot;send result:&quot;, send_result);&#125;)(); 不使用私钥的情况： 12345678910111213141516171819202122require(&#x27;dotenv&#x27;).config();const &#123; ethers &#125; = require(&quot;ethers&quot;);// 本地ganacheconst RPC_URL = &quot;http://localhost:8545&quot;var provider = new ethers.providers.JsonRpcProvider(RPC_URL);// 连接到Metamask// const provider = new ethers.providers.Web3Provider(window.ethereum)(async()=&gt;&#123; let signer = await provider.getSigner(); console.log(&quot;account balance: &quot;, (await signer.getBalance()).toString()); console.log(&quot;account nonce:&quot;, await signer.getTransactionCount()); let tx = &#123; to: &quot;0x7A5A87E93493de61804024FbA658249e21dcaFC0&quot;, value: ethers.utils.parseEther(&quot;0.001&quot;) &#125;; let send_result = await signer.sendTransaction(tx); console.log(&quot;send result:&quot;, send_result);&#125;)(); 合约交易 以普通的token转账为例，进行合约交易的代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950require(&#x27;dotenv&#x27;).config();const &#123; ethers &#125; = require(&quot;ethers&quot;);const &#123;ACCOUNT_PRIVATE_KEY, RPC_URL&#125; = process.env;// 准备好合约地址和abiconst TOKEN_INFO = require(&quot;./token_info&quot;);var provider = new ethers.providers.JsonRpcProvider(RPC_URL);const signer = new ethers.Wallet(ACCOUNT_PRIVATE_KEY, provider);(async()=&gt;&#123; // 初始化合约对象 let token_contract = new ethers.Contract( TOKEN_INFO.address, TOKEN_INFO.abi, provider ); let contract_with_signer = token_contract.connect(signer); // 只读的方法不需要signer，可以直接调 let token_balance = await token_contract.balanceOf(signer.address); console.log(&quot;token balance:&quot;, token_balance); let amount = ethers.utils.parseEther(&quot;1&quot;); // 预估gas消耗 let cost_gas = await contract_with_signer.estimateGas.transfer(signer.address, amount); console.log(&quot;cost gas:&quot;, cost_gas.toNumber()); // 调用call，不会实际进行交易，通常用来判断交易是否能成功 let call_result = await contract_with_signer.callStatic.transfer(signer.address, amount); console.log(&quot;call_result:&quot;, call_result); // 进行交易， overrides可以省略 let tx = await contract_with_signer.transfer(signer.address, amount, overrides=&#123; // gasPrice: maxFeePerGas: ethers.utils.parseUnits(&quot;5&quot;, &quot;gwei&quot;), maxPriorityFeePerGas: ethers.utils.parseUnits(&quot;3&quot;, &quot;gwei&quot;), gasLimit: cost_gas, // value: &quot;0x0&quot;, // nonce: &quot;0x1&quot; &#125;); console.log(&quot;tx:&quot;, tx); // 等待交易结果 let tx_response = await tx.wait(); console.log(&quot;tx_response:&quot;, tx_response); &#125;)();","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[]},{"title":"使用hardhat发布并在Etherscan验证合约","slug":"hardhat-verify-eth","date":"2022-06-17T07:19:09.000Z","updated":"2022-06-17T09:05:37.903Z","comments":true,"path":"2022/06/17/hardhat-verify-eth/","link":"","permalink":"http://sakiya.top/2022/06/17/hardhat-verify-eth/","excerpt":"","text":"安装hardhat 首先把相关环境装一装 12npm install --save hardhatnpx hardhat 我这里选择 “Create a basic sample project”，会创建一个样例project，然后会提示要不要装一些依赖之类的，一路选yes。 成功了会在目录生成一些文件，有一个样例合约： contracts/Greeter.sol 这个合约可以随便改点东西，比如加个没用的函数之类（主要是后面验证的时候如果是同样的代码，会被自动识别出来并自动验证）。 还有一些其他需要的插件之类的可以装一下： 1234# 实现从.env读取参数配置npm install dotenv# etherscan的插件，可以实现发布合约npm install --save-dev @nomiclabs/hardhat-etherscan 编译测试合约 1234# 编译npx hardhat compile# 测试npx hardhat test 正常来说这两步应该没什么问题，测试代码在test/sample-test.js ，也可以根据自己的需求进行修改。 发布合约 为了发布合约，首先需要准备一些东西，这篇文章的合约在rinkeby测试网进行发布测试。 发布合约的私钥。 对应网络的rpc url，这里使用alchemyapi，没有可以去免费注册一个，或者你用infura或者别的都可以。 etherscan的API Key （只是发布不验证的话可以不用），可以去Etherscan注册一个，这是教程。 上面几样准备好以后，我们要修改一下配置。 创建一个.env文件，填入各种key： 123ALCHEMY_KEY = &quot;&lt;your alchemy key&gt;&quot;ACCOUNT_PRIVATE_KEY = &quot;&lt;your private key&gt;&quot;ETHSCAN_API_KEY = &quot;&lt;your etherscan api key&gt;&quot; 修改hardhat.config.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445require(&#x27;dotenv&#x27;).config();require(&quot;@nomiclabs/hardhat-waffle&quot;);require(&quot;@nomiclabs/hardhat-etherscan&quot;);// This is a sample Hardhat task. To learn how to create your own go to// https://hardhat.org/guides/create-task.htmltask(&quot;accounts&quot;, &quot;Prints the list of accounts&quot;, async (taskArgs, hre) =&gt; &#123; const accounts = await hre.ethers.getSigners(); for (const account of accounts) &#123; console.log(account.address); &#125;&#125;);const &#123; ALCHEMY_KEY, ACCOUNT_PRIVATE_KEY, ETHSCAN_API_KEY &#125; = process.env;// You need to export an object to set up your config// Go to https://hardhat.org/config/ to learn more/** * @type import(&#x27;hardhat/config&#x27;).HardhatUserConfig */module.exports = &#123; solidity: &quot;0.8.4&quot;, defaultNetwork: &quot;hardhat&quot;, networks: &#123; hardhat: &#123;&#125;, rinkeby: &#123; url: `https://eth-rinkeby.alchemyapi.io/v2/$&#123;ALCHEMY_KEY&#125;`, accounts: [`0x$&#123;ACCOUNT_PRIVATE_KEY&#125;`] &#125;, ethereum: &#123; chainId: 1, url: `https://eth-mainnet.alchemyapi.io/v2/$&#123;ALCHEMY_KEY&#125;`, accounts: [`0x$&#123;ACCOUNT_PRIVATE_KEY&#125;`] &#125;, &#125;, etherscan: &#123; // Your API key for Etherscan // Obtain one at https://etherscan.io/ apiKey: ETHSCAN_API_KEY &#125;&#125;; 接下来是编写发布合约的脚本，在样例中已经有了：scripts/sample-script.js， 如果有特殊需求，可以去修改或者重写一个。 然后就是执行这个脚本就可以发布了： 1npx hardhat run scripts/sample-script.js --network rinkeby 然后打开etherscan查找这个合约，可以看到此时并没有验证源码，接下来要上传并验证源码。 验证合约源码 安装并在hardhat.config.js中导入**@nomiclabs/hardhat-etherscan**包就可以使用verify指令： 1npx hardhat verify --network rinkeby DEPLOYED_CONTRACT_ADDRESS &quot;Constructor argument 1&quot; 解释一下，verify不需要指定具体使用那个合约，它会自动寻找匹配的合约进行验证，所以只需要已发布的合约地址和初始化合约的参数。比如样例就是： 1npx hardhat verify --network rinkeby 0xA9D399.... &quot;Hello, Hardhat!&quot; 另外，如果你的合约初始化参数比较复杂，就需要写一个js文件，比如你的初始化参数是这样的： 12345678struct Point &#123; uint x; uint y;&#125;contract Foo &#123; constructor (uint x, string s, Point memory point, bytes b) &#123; ... &#125;&#125; 那么你可以写个arguments.js文件： 12345678910module.exports = [ 50, &quot;a string argument&quot;, &#123; x: 10, y: 5, &#125;, // bytes have to be 0x-prefixed &quot;0xabcdef&quot;,]; 然后使用下面指令进行验证： 1npx hardhat verify --constructor-args arguments.js DEPLOYED_CONTRACT_ADDRESS 解决国内验证失败的问题 如果你的网络环境是国内的，那么就会产生下面的错误： 123Error in plugin @nomiclabs/hardhat-etherscan: Failed to send contract verification request.Endpoint URL: https://api-rinkeby.etherscan.io/apiReason: Connect Timeout Error 想要解决这个问题，首先你需要一个代理，然后想办法让请求走代理就行了。 翻了一下 @nomiclabs/hardhat-etherscan 的源码，发现发送请求使用的是 undici 。没用过这个，简单看了一下github，感觉写的不太清楚，没发现怎么使用代理。算了，直接换成request请求好了，用别的方法也差不多，反正把这个请求改成走代理就行了。 先打开文件： node_modules/@nomiclabs/hardhat-etherscan/dist/src/etherscan/EtherscanService.js 修改函数： verifyContract 12345678910111213141516171819202122232425262728293031323334353637383940async function verifyContract(url, req) &#123; // 原来的代码， 使用undici发请求 // const &#123; request &#125; = await Promise.resolve().then(() =&gt; __importStar(require(&quot;undici&quot;))); // const parameters = new URLSearchParams(Object.assign(&#123;&#125;, req)); // const method = &quot;POST&quot;; // const requestDetails = &#123; // method, // headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, // body: parameters.toString(), // &#125;; // 改成用request发，把proxy改成自己的代理就行了 const request = require(&quot;request&quot;); async function request_verify(url, data) &#123; return new Promise((resolve,reject) =&gt; &#123; request(&#123; proxy: &quot;http://localhost:7890&quot;, url: url, method: &quot;POST&quot;, headers: &#123; &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &#125;, form: data &#125;, (error, response, body) =&gt; &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(body); &#125; &#125;); &#125;); &#125; let response; try &#123; // response = await request(url, requestDetails); response = await request_verify(url, req); console.log(response); &#125; // 后面省略 .....&#125; 由于使用request返回值和原来的格式不同，肯定会报错的，这点应该无所谓了，看一下请求返回的内容成没成功就行了。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"Solana账号地址转换","slug":"solana-account-convert","date":"2022-06-16T13:46:44.000Z","updated":"2022-06-16T14:09:18.481Z","comments":true,"path":"2022/06/16/solana-account-convert/","link":"","permalink":"http://sakiya.top/2022/06/16/solana-account-convert/","excerpt":"","text":"Solana 账号地址有多种表示方式，钱包和solscan上看到的一般是这种形式： Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB 而用solana的web3.js库来生成的账号的话： 123const web3 = require(&#x27;@solana/web3.js&#x27;);let account = web3.Keypair.generate();console.log(&quot;account:&quot;, account) 结果是这样的： account: Keypair { _keypair: { publicKey: Uint8Array(32) [ 156, 43, 124, 173, 206, 237, 208, 7, 190, 155, 53, 17, 32, 162, 249, 149, ​ 23, 5, 175, 121, 108, 35, 19, 47, 155, 224, 138, 4, 62, 4, 54, 118 ], secretKey: Uint8Array(64) [ ​ 79, 206, 135, 1, 237, 132, 132, 64, 32, 175, 29, ​ 69, 175, 166, 41, 124, 170, 120, 225, 16, 140, 8, 125, 136, 37, 145, 114, 177, 220, 25, 203, 190, 156, ​ 43, 124, 173, 206, 237, 208, 7, 190, 155, 53, 17, ​ 32, 162, 249, 149, 23, 5, 175, 121, 108, 35, 19, ​ 47, 155, 224, 138, 4, 62, 4, 54, 118 ] } } 二者转换并不难，只要知道它是如何编码的，solana的地址采用的是base58编码，比特币用的就是这种方式。 可以直接使用bs58的库来进行转化，代码如下： 123456789101112const web3 = require(&#x27;@solana/web3.js&#x27;);const bs58 = require(&#x27;bs58&#x27;);let account = web3.Keypair.generate();console.log(&quot;account:&quot;, account)// bytes to base58let private_key = bs58.encode(account.secretKey);console.log(&quot;private_key:&quot;, private_key);// base68 to bytesconst decoded_key = bs58.decode(private_key);console.log(&quot;decoded_key:&quot;, decoded_key);let account_restore = new web3.Account(decoded_key);console.log(&quot;account_restore:&quot;, account_restore) 结果如下： account: Keypair { _keypair: { publicKey: Uint8Array(32) [ 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, ​ 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ], secretKey: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, ​ 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] } } private_key: 62pGE5gVtL82roxrtQC2Hn5aaWLan9CQ64bwm76pQTdy8L4n9mxDqqEu7xHqZuYZCjxcLf47rwT4H1SEHEhFr7X7 decoded_key: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] account_restore: Account { _keypair: { publicKey: Uint8Array(32) [ 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, ​ 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ], secretKey: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, ​ 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] } }","categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"http://sakiya.top/tags/Solana/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"新博客开张","slug":"first-blog","date":"2022-06-15T07:14:40.000Z","updated":"2022-06-15T07:00:30.684Z","comments":true,"path":"2022/06/15/first-blog/","link":"","permalink":"http://sakiya.top/2022/06/15/first-blog/","excerpt":"","text":"最近有点怠惰，打算继续写写博客。 之前在csdn写的，但csdn环境越来越差，不登陆不能复制，还看不到全文啥的，反正感觉挺烦的。 为了看的人考虑，还是搬个家吧。 比较懒，博客直接用的hexo模版，随便弄了一下，后面有心情了再好好搞搞吧。 csdn上的文章，有时间可能会把阅读量大的搬运一些过来，都搬过来工作量有点大。 希望能坚持下去～","categories":[{"name":"随笔","slug":"随笔","permalink":"http://sakiya.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://sakiya.top/categories/nodejs/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"随笔","slug":"随笔","permalink":"http://sakiya.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"http://sakiya.top/tags/Solana/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]}