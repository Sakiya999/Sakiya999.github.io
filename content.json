{"meta":{"title":"Sakiya的个人博客","subtitle":"","description":"","author":"John Doe","url":"http://sakiya.top","root":"/"},"pages":[{"title":"404 Not Found：你来到了一座还未开拓的荒岛","date":"2022-06-14T06:59:16.400Z","updated":"2022-06-14T06:59:16.400Z","comments":false,"path":"/404.html","permalink":"http://sakiya.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-06-14T07:02:13.903Z","updated":"2022-06-14T07:02:13.903Z","comments":false,"path":"about/index.html","permalink":"http://sakiya.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-06-14T06:59:47.715Z","updated":"2022-06-14T06:59:47.714Z","comments":false,"path":"tags/index.html","permalink":"http://sakiya.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-06-14T07:01:59.367Z","updated":"2022-06-14T07:01:59.367Z","comments":false,"path":"categories/index.html","permalink":"http://sakiya.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用hardhat发布并在Etherscan验证合约","slug":"hardhat-verify-eth","date":"2022-06-17T07:19:09.000Z","updated":"2022-06-17T09:05:37.903Z","comments":true,"path":"2022/06/17/hardhat-verify-eth/","link":"","permalink":"http://sakiya.top/2022/06/17/hardhat-verify-eth/","excerpt":"","text":"安装hardhat 首先把相关环境装一装 12npm install --save hardhatnpx hardhat 我这里选择 “Create a basic sample project”，会创建一个样例project，然后会提示要不要装一些依赖之类的，一路选yes。 成功了会在目录生成一些文件，有一个样例合约： contracts/Greeter.sol 这个合约可以随便改点东西，比如加个没用的函数之类（主要是后面验证的时候如果是同样的代码，会被自动识别出来并自动验证）。 还有一些其他需要的插件之类的可以装一下： 1234# 实现从.env读取参数配置npm install dotenv# etherscan的插件，可以实现发布合约npm install --save-dev @nomiclabs/hardhat-etherscan 编译测试合约 1234# 编译npx hardhat compile# 测试npx hardhat test 正常来说这两步应该没什么问题，测试代码在test/sample-test.js ，也可以根据自己的需求进行修改。 发布合约 为了发布合约，首先需要准备一些东西，这篇文章的合约在rinkeby测试网进行发布测试。 发布合约的私钥。 对应网络的rpc url，这里使用alchemyapi，没有可以去免费注册一个，或者你用infura或者别的都可以。 etherscan的API Key （只是发布不验证的话可以不用），可以去Etherscan注册一个，这是教程。 上面几样准备好以后，我们要修改一下配置。 创建一个.env文件，填入各种key： 123ALCHEMY_KEY = &quot;&lt;your alchemy key&gt;&quot;ACCOUNT_PRIVATE_KEY = &quot;&lt;your private key&gt;&quot;ETHSCAN_API_KEY = &quot;&lt;your etherscan api key&gt;&quot; 修改hardhat.config.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445require(&#x27;dotenv&#x27;).config();require(&quot;@nomiclabs/hardhat-waffle&quot;);require(&quot;@nomiclabs/hardhat-etherscan&quot;);// This is a sample Hardhat task. To learn how to create your own go to// https://hardhat.org/guides/create-task.htmltask(&quot;accounts&quot;, &quot;Prints the list of accounts&quot;, async (taskArgs, hre) =&gt; &#123; const accounts = await hre.ethers.getSigners(); for (const account of accounts) &#123; console.log(account.address); &#125;&#125;);const &#123; ALCHEMY_KEY, ACCOUNT_PRIVATE_KEY, ETHSCAN_API_KEY &#125; = process.env;// You need to export an object to set up your config// Go to https://hardhat.org/config/ to learn more/** * @type import(&#x27;hardhat/config&#x27;).HardhatUserConfig */module.exports = &#123; solidity: &quot;0.8.4&quot;, defaultNetwork: &quot;hardhat&quot;, networks: &#123; hardhat: &#123;&#125;, rinkeby: &#123; url: `https://eth-rinkeby.alchemyapi.io/v2/$&#123;ALCHEMY_KEY&#125;`, accounts: [`0x$&#123;ACCOUNT_PRIVATE_KEY&#125;`] &#125;, ethereum: &#123; chainId: 1, url: `https://eth-mainnet.alchemyapi.io/v2/$&#123;ALCHEMY_KEY&#125;`, accounts: [`0x$&#123;ACCOUNT_PRIVATE_KEY&#125;`] &#125;, &#125;, etherscan: &#123; // Your API key for Etherscan // Obtain one at https://etherscan.io/ apiKey: ETHSCAN_API_KEY &#125;&#125;; 接下来是编写发布合约的脚本，在样例中已经有了：scripts/sample-script.js， 如果有特殊需求，可以去修改或者重写一个。 然后就是执行这个脚本就可以发布了： 1npx hardhat run scripts/sample-script.js --network rinkeby 然后打开etherscan查找这个合约，可以看到此时并没有验证源码，接下来要上传并验证源码。 验证合约源码 安装并在hardhat.config.js中导入**@nomiclabs/hardhat-etherscan**包就可以使用verify指令： 1npx hardhat verify --network rinkeby DEPLOYED_CONTRACT_ADDRESS &quot;Constructor argument 1&quot; 解释一下，verify不需要指定具体使用那个合约，它会自动寻找匹配的合约进行验证，所以只需要已发布的合约地址和初始化合约的参数。比如样例就是： 1npx hardhat verify --network rinkeby 0xA9D399.... &quot;Hello, Hardhat!&quot; 另外，如果你的合约初始化参数比较复杂，就需要写一个js文件，比如你的初始化参数是这样的： 12345678struct Point &#123; uint x; uint y;&#125;contract Foo &#123; constructor (uint x, string s, Point memory point, bytes b) &#123; ... &#125;&#125; 那么你可以写个arguments.js文件： 12345678910module.exports = [ 50, &quot;a string argument&quot;, &#123; x: 10, y: 5, &#125;, // bytes have to be 0x-prefixed &quot;0xabcdef&quot;,]; 然后使用下面指令进行验证： 1npx hardhat verify --constructor-args arguments.js DEPLOYED_CONTRACT_ADDRESS 解决国内验证失败的问题 如果你的网络环境是国内的，那么就会产生下面的错误： 123Error in plugin @nomiclabs/hardhat-etherscan: Failed to send contract verification request.Endpoint URL: https://api-rinkeby.etherscan.io/apiReason: Connect Timeout Error 想要解决这个问题，首先你需要一个代理，然后想办法让请求走代理就行了。 翻了一下 @nomiclabs/hardhat-etherscan 的源码，发现发送请求使用的是 undici 。没用过这个，简单看了一下github，感觉写的不太清楚，没发现怎么使用代理。算了，直接换成request请求好了，用别的方法也差不多，反正把这个请求改成走代理就行了。 先打开文件： node_modules/@nomiclabs/hardhat-etherscan/dist/src/etherscan/EtherscanService.js 修改函数： verifyContract 12345678910111213141516171819202122232425262728293031323334353637383940async function verifyContract(url, req) &#123; // 原来的代码， 使用undici发请求 // const &#123; request &#125; = await Promise.resolve().then(() =&gt; __importStar(require(&quot;undici&quot;))); // const parameters = new URLSearchParams(Object.assign(&#123;&#125;, req)); // const method = &quot;POST&quot;; // const requestDetails = &#123; // method, // headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, // body: parameters.toString(), // &#125;; // 改成用request发，把proxy改成自己的代理就行了 const request = require(&quot;request&quot;); async function request_verify(url, data) &#123; return new Promise((resolve,reject) =&gt; &#123; request(&#123; proxy: &quot;http://localhost:7890&quot;, url: url, method: &quot;POST&quot;, headers: &#123; &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &#125;, form: data &#125;, (error, response, body) =&gt; &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(body); &#125; &#125;); &#125;); &#125; let response; try &#123; // response = await request(url, requestDetails); response = await request_verify(url, req); console.log(response); &#125; // 后面省略 .....&#125; 由于使用request返回值和原来的格式不同，肯定会报错的，这点应该无所谓了，看一下请求返回的内容成没成功就行了。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"Solana账号地址转换","slug":"solana-account-convert","date":"2022-06-16T13:46:44.000Z","updated":"2022-06-16T14:09:18.481Z","comments":true,"path":"2022/06/16/solana-account-convert/","link":"","permalink":"http://sakiya.top/2022/06/16/solana-account-convert/","excerpt":"","text":"Solana 账号地址有多种表示方式，钱包和solscan上看到的一般是这种形式： Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB 而用solana的web3.js库来生成的账号的话： 123const web3 = require(&#x27;@solana/web3.js&#x27;);let account = web3.Keypair.generate();console.log(&quot;account:&quot;, account) 结果是这样的： account: Keypair { _keypair: { publicKey: Uint8Array(32) [ 156, 43, 124, 173, 206, 237, 208, 7, 190, 155, 53, 17, 32, 162, 249, 149, ​ 23, 5, 175, 121, 108, 35, 19, 47, 155, 224, 138, 4, 62, 4, 54, 118 ], secretKey: Uint8Array(64) [ ​ 79, 206, 135, 1, 237, 132, 132, 64, 32, 175, 29, ​ 69, 175, 166, 41, 124, 170, 120, 225, 16, 140, 8, 125, 136, 37, 145, 114, 177, 220, 25, 203, 190, 156, ​ 43, 124, 173, 206, 237, 208, 7, 190, 155, 53, 17, ​ 32, 162, 249, 149, 23, 5, 175, 121, 108, 35, 19, ​ 47, 155, 224, 138, 4, 62, 4, 54, 118 ] } } 二者转换并不难，只要知道它是如何编码的，solana的地址采用的是base58编码，比特币用的就是这种方式。 可以直接使用bs58的库来进行转化，代码如下： 123456789101112const web3 = require(&#x27;@solana/web3.js&#x27;);const bs58 = require(&#x27;bs58&#x27;);let account = web3.Keypair.generate();console.log(&quot;account:&quot;, account)// bytes to base58let private_key = bs58.encode(account.secretKey);console.log(&quot;private_key:&quot;, private_key);// base68 to bytesconst decoded_key = bs58.decode(private_key);console.log(&quot;decoded_key:&quot;, decoded_key);let account_restore = new web3.Account(decoded_key);console.log(&quot;account_restore:&quot;, account_restore) 结果如下： account: Keypair { _keypair: { publicKey: Uint8Array(32) [ 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, ​ 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ], secretKey: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, ​ 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] } } private_key: 62pGE5gVtL82roxrtQC2Hn5aaWLan9CQ64bwm76pQTdy8L4n9mxDqqEu7xHqZuYZCjxcLf47rwT4H1SEHEhFr7X7 decoded_key: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] account_restore: Account { _keypair: { publicKey: Uint8Array(32) [ 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, 29, 19, 203, 55, ​ 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ], secretKey: Uint8Array(64) [ 251, 166, 106, 213, 81, 158, 129, 72, 55, 59, 204, 113, 209, 241, 255, 209, 16, 69, 217, 91, 216, 177, 152, 187, 66, 3, 210, 39, 251, 109, 206, 11, 188, 157, 166, 231, 52, 155, 151, 249, 186, 174, 13, 79, ​ 29, 19, 203, 55, 64, 97, 209, 231, 17, 1, 90, 129, 177, 34, 238, 137, 76, 190, 175, 114 ] } }","categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"http://sakiya.top/tags/Solana/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"新博客开张","slug":"first-blog","date":"2022-06-15T07:14:40.000Z","updated":"2022-06-15T07:00:30.684Z","comments":true,"path":"2022/06/15/first-blog/","link":"","permalink":"http://sakiya.top/2022/06/15/first-blog/","excerpt":"","text":"最近有点怠惰，打算继续写写博客。 之前在csdn写的，但csdn环境越来越差，不登陆不能复制，还看不到全文啥的，反正感觉挺烦的。 为了看的人考虑，还是搬个家吧。 比较懒，博客直接用的hexo模版，随便弄了一下，后面有心情了再好好搞搞吧。 csdn上的文章，有时间可能会把阅读量大的搬运一些过来，都搬过来工作量有点大。 希望能坚持下去～","categories":[{"name":"随笔","slug":"随笔","permalink":"http://sakiya.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"随笔","slug":"随笔","permalink":"http://sakiya.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://sakiya.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"Solana","slug":"Solana","permalink":"http://sakiya.top/tags/Solana/"},{"name":"区块链","slug":"区块链","permalink":"http://sakiya.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]}